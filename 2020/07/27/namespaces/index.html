<!DOCTYPE html><html xmlns:v-bind="http://www.w3.org/1999/xhtml"><head><meta name="generator" content="Hexo 3.9.0"><title>Namespaces and Scope in Python - Avalon</title><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="John Reese"><meta name="description" content="UnboundLocalError - local variable &#39;x&#39; referenced before assignment"><meta name="keywords" content><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><meta name="theme-color" content="#ffffff"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous"><link rel="stylesheet" href="/css/journal.css?91944013"><script src="/js/loadCSS.js"></script><script>loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Material+Icons"),function(e){var t,a={kitId:"dwg1tuc",scriptTimeout:3e3,async:!0},o=e.documentElement,s=setTimeout(function(){o.className=o.className.replace(/\bwf-loading\b/g,"")+" wf-inactive"},a.scriptTimeout),c=e.createElement("script"),i=!1,n=e.getElementsByTagName("script")[0];o.className+=" wf-loading",c.src="https://use.typekit.net/"+a.kitId+".js",c.async=!0,c.onload=c.onreadystatechange=function(){if(t=this.readyState,!(i||t&&"complete"!=t&&"loaded"!=t)){i=!0,clearTimeout(s);try{Typekit.load(a)}catch(e){}}},n.parentNode.insertBefore(c,n)}(document)</script><noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora|Montserrat|Anonymous+Pro:400|Material+Icons"></noscript><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div id="top"></div><div id="app"><div class="single-column-drawer-container" ref="drawer" v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }"><div class="drawer-content"><div class="drawer-menu"><a class="a-block drawer-menu-item false" href="http://yoursite.com">Home </a><a class="a-block drawer-menu-item false" href="/archives">記事一覽 </a><a class="a-block drawer-menu-item false" href="/about/index.html">關於我 </a><a class="a-block drawer-menu-item false" href="/categories/index.html">分類 </a><a class="a-block drawer-menu-item false" href="/tags/index.html">標簽</a></div></div></div><transition name="fade"><div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div></transition><nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container"><div ref="navBackground" class="nav-background"></div><div class="container container-narrow nav-content"><button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer"><i class="material-icons">menu</i></button> <a ref="navTitle" class="navbar-brand" href="/">Avalon</a></div></nav><div class="single-column-header-container" ref="pageHead" v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }"><a href="/"><div class="single-column-header-title">Avalon</div><div class="single-column-header-subtitle">Welcome!!</div></a></div><div ref="sideContainer" class="side-container"><a class="a-block nav-head false" href="/"><div class="nav-title">远い理想郷</div><div class="nav-subtitle">お帰りなさい</div></a><div class="nav-link-list"><a class="a-block no-tint nav-link-item false" href="/archives">記事一覽 </a><a class="a-block nav-link-item false" href="/about/index.html">關於我 </a><a class="a-block nav-link-item false" href="/categories/index.html">分類 </a><a class="a-block nav-link-item false" href="/tags/index.html">標簽</a></div><div class="nav-footer">Proudly published with Hexo<br>Theme <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> by <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a><br>&copy; 2020 <a href="http://yoursite.com">Avalon</a></div></div><div ref="extraContainer" class="extra-container"><div class="pagination"><a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }"><i class="material-icons pagination-action-icon">keyboard_arrow_up</i></a></div></div><div ref="streamContainer" class="stream-container"><div class="post-list-container post-list-container-shadow"><div class="post"><div class="post-head-wrapper" style="background-image:url(/2020/07/27/namespaces/cover.jpg)"><div class="post-title">Namespaces and Scope in Python<div class="post-meta"><time datetime="2020-07-27T15:06:44.000Z" itemprop="datePublished">2020-07-27 11:06 </time>&nbsp; <i class="material-icons">folder</i> <a href="/categories/Python/">Python</a>, <a href="/categories/Python/Namespaces/">Namespaces</a> <i class="material-icons">label</i> <a href="/tags/Python/">Python</a></div></div></div><div class="post-body-wrapper"><div class="post-body"><h3 id="an-example">An Example</h3><p>Let's first look at an example and see what the output should be when executed.</p><div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="op">&gt;&gt;&gt;</span> x <span class="op">=</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> foo():</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">...     <span class="bu">print</span>(x)</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">...     x <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="op">&gt;&gt;&gt;</span> foo()</a></code></pre></div><p>The answer is as below</p><div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="op">&gt;&gt;&gt;</span> foo()</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  ...</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="pp">UnboundLocalError</span>: local variable <span class="st">&#39;x&#39;</span> referenced before assignment</a></code></pre></div><p>This is where namespaces and scopes are used in Python. Before we find out these concepts, let's first answer what names are in Python. A name in Python is just a way to access an object.</p><div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="op">&gt;&gt;&gt;</span> a <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="op">&gt;&gt;&gt;</span> b <span class="op">=</span> <span class="kw">lambda</span> x: x</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="op">&gt;&gt;&gt;</span> <span class="kw">class</span> C:</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">...     <span class="cf">pass</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="op">&gt;&gt;&gt;</span> D <span class="op">=</span> C()</a></code></pre></div><p>In the snippet above, <code>a</code>, <code>b</code>, <code>C</code>, <code>D</code> are both names and we can see that a name can reference an integer, a function, a class or an object. Then what are namespaces in Python?</p><h3 id="namespaces-and-scopes">Namespaces and Scopes</h3><p>Simply speaking, a namespace is a system to control names in a program. There may be multiple names in one program and multilayers of namespaces ensure that these names won’t lead to any conflict. Generally, names with a shared name in different namespaces but reference different objects. Let's look at an example below to get the picture.</p><div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> x():</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">...     x <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">...     <span class="kw">def</span> foo():</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">...         x <span class="op">=</span> <span class="dv">2</span></a></code></pre></div><p>As we can see, there are 3 <code>x</code> in the above snippet, while <code>x</code> in the first line references a function and <code>x</code> in the second line references <code>1</code> and <code>x</code> in the fourth line references <code>2</code>. Most importantly, the value of <code>x</code> varies when it is used in different namespaces. In this case, the outermost <code>x</code> is defined in the <strong>global</strong> namespace and <code>x</code> in the middle is defined in the <strong>enclosed</strong> namespace while the innermost <code>x</code> is defined in the <strong>local</strong> namespace. Specifically,</p><ul><li><p>A local namespace covers local names within a function or a class. Python creates this namespace for every function called in a program. It remains active until the function returns.</p></li><li>An enclosed namespace typically arises in higher order functions and it covers the nested function and other names. Python creates this namespace for every higher order function. It also remains active until the function returns.</li><li>A global namespace covers the names from various imported modules and other names. Python creates this namespace for every module included in a program. It will last until the program ends.</li><li><p>A built-in namespace covers all built-in functions and built-in exception names like <code>print</code>, <code>len</code>, <code>ValueError</code> and so on. Python creates it as the interpreter starts and keeps it until you exit.</p></li></ul><p>Correspondingly, scopes determine which namespace a name belongs to and ensure that names can be used without any prefix. This guideline is called the <strong>LEGB</strong> rule illustrated as below.</p><h3 id="the-legb-rule">The LEGB Rule</h3><figure><img src="scopes.png" alt="scope"><figcaption>scope</figcaption></figure><p>This picture explains the order in which these namespaces are to be searched for scope resolution. Specifically, if a variable is not defined in the local scope, then it will be searched in outer scopes to check if there is such a variable.</p><div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="op">&gt;&gt;&gt;</span> x <span class="op">=</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> foo():</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">...     <span class="bu">print</span>(x)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">...     x <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="op">&gt;&gt;&gt;</span> foo()</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">Traceback (most recent call last):</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">  ...</a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="pp">UnboundLocalError</span>: local variable <span class="st">&#39;x&#39;</span> referenced before assignment</a></code></pre></div><p>Let's get back to the above example. There is a <code>x</code> variable in the global namespace but the assignment <code>x+=1</code> declares a variable in the local namespace and assign a value recursively. Hence, <code>print(x)</code> first finds and calls on a local variable without any reference and raises an exception. Even <code>print(x)</code> is executed before the assignment, there is still an error about how <code>x</code> should be properly used. This is because an assignment to a variable in a function makes that variable local to that function . Even <code>x += 1</code> changes to <code>x = 1</code>, there will be the same error. The compiler precompiles everything and assign each variable with its namespace.</p><h3 id="the-implementation-in-python">The Implementation in Python</h3><p>To amend the above snippet, we can use the keyword <code>global</code> or <code>nonlocal</code>. <code>global</code> is used to assign a value to a global object within a local namespace while <code>nonlocal</code> is used to assign a value to a object in a higher order function.</p><div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="op">&gt;&gt;&gt;</span> x <span class="op">=</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> foo():</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">...     <span class="kw">global</span> x</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">...     <span class="bu">print</span>(x)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">...     x <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="op">&gt;&gt;&gt;</span> foo()</a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="dv">10</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="op">&gt;&gt;&gt;</span> <span class="bu">print</span>(x)</a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="dv">11</span></a></code></pre></div><div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="op">&gt;&gt;&gt;</span> <span class="kw">def</span> foo():</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">...     x <span class="op">=</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">...     <span class="kw">def</span> foo2():</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">...         <span class="kw">nonlocal</span> x</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">...         <span class="bu">print</span>(x)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">...         x <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">...     foo2(x)</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">...     <span class="bu">print</span>(x)</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="op">&gt;&gt;&gt;</span> foo()</a>
<a class="sourceLine" id="cb7-10" data-line-number="10"><span class="dv">10</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11"><span class="dv">11</span></a></code></pre></div><p>In Python, namespaces are implemented in the form of dictionaries. It maintains a name-to-object mapping where names act as keys and objects as values. And we can use built-in functions <code>globals</code> and <code>locals</code> to see these mappings.</p><div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" data-line-number="1">a <span class="op">=</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">def</span> function():</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    a <span class="op">=</span> <span class="dv">11</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    <span class="bu">print</span>(<span class="bu">locals</span>())</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    <span class="kw">def</span> foo():</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">        a <span class="op">=</span> <span class="dv">12</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">        <span class="bu">print</span>(<span class="bu">locals</span>())</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    <span class="cf">return</span> foo</a>
<a class="sourceLine" id="cb8-9" data-line-number="9"></a>
<a class="sourceLine" id="cb8-10" data-line-number="10"><span class="bu">print</span>(<span class="bu">globals</span>())</a>
<a class="sourceLine" id="cb8-11" data-line-number="11"><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">    function()()</a></code></pre></div><p>And we can get the below output if we run the above snippet.</p><div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" data-line-number="1">{<span class="st">&#39;__name__&#39;</span>: <span class="st">&#39;__main__&#39;</span>, <span class="st">&#39;__doc__&#39;</span>: <span class="va">None</span>, <span class="st">&#39;__package__&#39;</span>: <span class="va">None</span>, <span class="st">&#39;__loader__&#39;</span>: ..., <span class="st">&#39;__spec__&#39;</span>: <span class="va">None</span>, <span class="st">&#39;__annotations__&#39;</span>: {}, <span class="st">&#39;__builtins__&#39;</span>: <span class="op">&lt;</span>module <span class="st">&#39;builtins&#39;</span> (built<span class="op">-</span><span class="kw">in</span>)<span class="op">&gt;</span>, <span class="st">&#39;__file__&#39;</span>: <span class="st">&#39;...&#39;</span>, <span class="st">&#39;__cached__&#39;</span>: <span class="va">None</span>, <span class="st">&#39;a&#39;</span>: <span class="dv">10</span>, <span class="st">&#39;function&#39;</span>: <span class="op">&lt;</span>function function at <span class="bn">0x000001D740ED64C8</span><span class="op">&gt;</span>}</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">{<span class="st">&#39;a&#39;</span>: <span class="dv">11</span>}</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">{<span class="st">&#39;a&#39;</span>: <span class="dv">12</span>}</a></code></pre></div><p>These 3 dictionaries represent 3 different namespaces where the key of <code>'a'</code> in different namespaces has different values. Something special about <code>globals</code> is that it is not read-only meaning we can add a key-value pair or update the existing key-value pair to the dictionary like</p><div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="bu">globals</span>()[<span class="st">&#39;a&#39;</span>] <span class="op">=</span> <span class="dv">13</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="bu">print</span>(<span class="st">&#39;a =&#39;</span>, a) <span class="co"># The output will be &#39;a = 13&#39;.</span></a></code></pre></div><h3 id="class-and-instance-namespaces">Class and Instance Namespaces</h3><p>Things are a bit different when it comes to classes and instances. Unlike what is covered above, accessing an instance attribute or a class attribute requires a prefix typically with the keyword <code>self</code>. For example, what is the expected output when we run the snippet as below?</p><div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">class</span> A:</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">    a <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, val):</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">        <span class="bu">print</span>(a)</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">        <span class="va">self</span>.a <span class="op">=</span> val</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">        <span class="bu">print</span>(a)</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">_ <span class="op">=</span> A(<span class="dv">2</span>)</a></code></pre></div><p>The answer is that it will comes with a <code>NameError: name 'a' is not defined</code> in line 4. Because of the scope resolution, <code>a</code> is first searched in the constructor's local namespace and then searched in the global namespace while it doesn't access any class attribute at all. Another great example is</p><div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">class</span> A:</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">    a <span class="op">=</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    b <span class="op">=</span> <span class="bu">list</span>(a <span class="op">+</span> i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>))</a></code></pre></div><p>There will be also a <code>NameError: name 'a' is not defined</code> in line 3 since what is inside the list is a generator expression. In Python, generator expressions are implemented in a function scope. The scope of names defined in a class block is limited to the class block; it does not extend to the code blocks of methods - this includes generator expressions in list comprehensions.</p><p>But if we change <code>print(a)</code> into <code>print(self.a)</code> in line 4 and line 6, then we will get <code>1</code> and <code>2</code> as the output.</p><div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">class</span> A:</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">    a <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, val):</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">        <span class="bu">print</span>(<span class="va">self</span>.a)</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">        <span class="va">self</span>.a <span class="op">=</span> val</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">        <span class="bu">print</span>(<span class="va">self</span>.a)</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">_ <span class="op">=</span> A(<span class="dv">2</span>)</a></code></pre></div><p>The first <code>self.a</code> in line 4 references the class variable defined in line 2 while the second <code>self.a</code> in line 6 references the instance variable defined in line 5. If we delete the second line and there is no such class variable,</p><div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">class</span> A:</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, val):</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">        <span class="bu">print</span>(<span class="va">self</span>.a)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">        <span class="va">self</span>.a <span class="op">=</span> val</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">_ <span class="op">=</span> A(<span class="dv">2</span>)</a></code></pre></div><p>then the search will proceed to look in its base class which is the <code>Object</code> class to see if there is such a variable called <code>a</code>.</p><p>Generally speaking,</p><ol type="1"><li>if the same attribute name occurs in both an instance and in its corresponding class, then attribute lookup prioritizes the instance.</li><li><p>If the attribute is not found in the instance attributes, then the search proceeds to look in the class attributes.</p></li><li>If the attribute is not found in the class, then the search proceeds to look in the base class.</li><li><p>If this class has multiple parent classes, then the search follows a Method Resolution Order(<a href="https://www.python.org/download/releases/2.3/mro/" target="_blank" rel="noopener">MRO</a>) to continue. This can be simply thought of as a depth-first, left-to-right and not searching twice in the same class procedure.</p></li></ol><p>Here is an official <a href="https://docs.python.org/3/reference/executionmodel.html?highlight=naming%20binding#naming-and-binding" target="_blank" rel="noopener">documentation</a> explaining the resolution of names just for reference.</p><h3 id="appendix-classmethod-and-staticmethod">Appendix: <code>@classmethod</code> and <code>@staticmethod</code></h3><p>Technically, this is not the content of namespaces and scopes in Python, but it is kind of similar to accessing method attributes from an instance level and a class level.</p><div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">class</span> A:</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">    <span class="kw">def</span> foo(arg1, arg2):</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">        <span class="bu">print</span>(arg1, arg2)</a></code></pre></div><p>Can we call <code>foo</code> method from the class level and from the instance level?</p><div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="op">&gt;&gt;&gt;</span> A.foo(<span class="dv">1</span>, <span class="dv">2</span>) </a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="dv">1</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="op">&gt;&gt;&gt;</span> A().foo(<span class="dv">2</span>)  </a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="op">&lt;</span>__main__.A <span class="bu">object</span> at <span class="bn">0x000001F51417C4C8</span><span class="op">&gt;</span> <span class="dv">2</span></a></code></pre></div><p>If <code>foo</code> is called as an instance method, then there is only 1 parameter remaining since <code>arg1</code> is treated as the object. That is to say, <code>A().foo(2)</code> is equivalent to <code>A.foo(A(), 2)</code>. But if there is a function without any argument, then we cannot call this function from an instance level.</p><div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">class</span> A:</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">    <span class="kw">def</span> foo():</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">        <span class="bu">print</span>(<span class="st">&quot;Unbound Methods.&quot;</span>)</a></code></pre></div><p>Instances of <code>A</code> cannot call <code>foo</code> because <code>foo</code> is an unbound method (while unbound methods are removed in Python 3). Methods that do not have an instance of the class as the first argument are known as unbound methods. Here comes the <code>@staticmethod</code> decorator.</p><div class="sourceCode" id="cb18"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">class</span> A:</a>
<a class="sourceLine" id="cb18-2" data-line-number="2">    <span class="at">@staticmethod</span> </a>
<a class="sourceLine" id="cb18-3" data-line-number="3">    <span class="kw">def</span> foo():</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">        <span class="bu">print</span>(<span class="st">&quot;Static Methods.&quot;</span>)</a></code></pre></div><p>For now, <code>@staticmethod</code> makes <code>foo</code> bound to instances of <code>A</code> and we will get consistent results if we call <code>foo</code> either from a class or from an instance. Actually, <code>@staticmthod</code> is to ensure the consistency and to make instances work smoothly with this method (removing <code>@staticmethod</code> doesn't influence calling <code>foo</code> from a class).</p><div class="sourceCode" id="cb19"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="op">&gt;&gt;&gt;</span> A.foo()</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">Static Methods.</a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="op">&gt;&gt;&gt;</span> A().foo()</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">Static Methods.</a></code></pre></div><p>Static methods do not require instance creation and are typically called from a class level. They are faster and usually implemented as utility functions. This is similar to where static methods are used in other languages like JAVA.</p><p>Where are <code>@classmethod</code> used in Python? Let's look at an example</p><div class="sourceCode" id="cb20"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">class</span> Date:</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, day<span class="op">=</span><span class="dv">1</span>, month<span class="op">=</span><span class="dv">1</span>, year<span class="op">=</span><span class="dv">1970</span>):</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">        <span class="va">self</span>.day <span class="op">=</span> day</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">        <span class="va">self</span>.month <span class="op">=</span> month</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">        <span class="va">self</span>.year <span class="op">=</span> year</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    </a>
<a class="sourceLine" id="cb20-7" data-line-number="7">    <span class="at">@classmethod</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8">    <span class="kw">def</span> fromString(cls, dateStr):</a>
<a class="sourceLine" id="cb20-9" data-line-number="9">        day, month, year <span class="op">=</span> dateStr.split(<span class="st">&#39;-&#39;</span>)</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">        <span class="cf">return</span> cls(day, month, year)</a></code></pre></div><p>As we can see, the above method decorated by <code>classmethod</code> takes a date in string and returns an instance of <code>Date</code>. That's where <code>@classmethod</code> decorators are mostly used. Typically, class methods take <code>cls</code> as the first argument mostly to return a new object. There are some examples in Python like</p><div class="sourceCode" id="cb21"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="op">&gt;&gt;&gt;</span> <span class="bu">dict</span>.fromkeys(<span class="st">&quot;ab&quot;</span>)</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">{<span class="st">&#39;a&#39;</span>: <span class="va">None</span>, <span class="st">&#39;b&#39;</span>: <span class="va">None</span>}</a></code></pre></div><p>When are static methods and class methods to be introduced? When the method only depends on its parameters while the <strong>instance state has no effect</strong> on the method behavior but it's something <strong>relative</strong> to the class. Then the method can be implemented as static. If it doesn't have anything to do with the class, then it's better to implement it as a standalone function. As for class methods, <code>cls</code> must be used in the implementation otherwise static methods or standalone functions are better.</p><p>Here is a <a href="https://www.tutorialspoint.com/class-method-vs-static-method-in-python" target="_blank" rel="noopener">table</a> displaying the <strong>difference between static methods and class methods</strong></p><table><colgroup><col style="width:40%"><col style="width:59%"></colgroup><thead><tr class="header"><th>Class Methods</th><th>Static Methods</th></tr></thead><tbody><tr class="odd"><td>Take <code>cls</code> as first argument.</td><td>Can go without any parameter.</td></tr><tr class="even"><td>Can access and modify the class state.</td><td>Cannot access or modify the class or the instance state.</td></tr><tr class="odd"><td>Mostly implemented as factory methods.</td><td>Mostly implemented as utility methods.</td></tr></tbody></table><h3 id="appendix-2-single-and-double-underscores">Appendix 2: Single and Double underscores</h3><p><strong>Single Underscore</strong></p><p>Names, in a class, with a leading underscore like <code>_foo</code> are simply to indicate that the attribute or method is intended to be private even though there is nothing really private in Python. From <a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP-8</a></p><blockquote><p><code>_single_leading_underscore</code>: weak &quot;internal use&quot; indicator. E.g. <code>from M import *</code> does not import objects whose names start with an underscore.</p><p><code>single_trailing_underscore_</code>: used by convention to avoid conflicts with Python keyword, e.g.</p><blockquote><p>def __init__(self, class_='class')</p></blockquote></blockquote><p><strong>Double Underscore (Name Mangling)</strong></p><blockquote><p><code>__double_leading_underscore</code>: when naming a class attribute, invokes name mangling (inside class FooBar, <code>__boo</code> becomes <code>_FooBar__boo</code>.</p></blockquote><p>For example,</p><div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="kw">class</span> A:</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">    <span class="kw">def</span> __foo(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">        <span class="cf">pass</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4"><span class="op">&gt;&gt;&gt;</span> a <span class="op">=</span> A()</a>
<a class="sourceLine" id="cb22-5" data-line-number="5"><span class="op">&gt;&gt;&gt;</span> a.__foo()</a>
<a class="sourceLine" id="cb22-6" data-line-number="6"><span class="pp">AttributeError</span>: <span class="st">&#39;A&#39;</span> <span class="bu">object</span> has no attribute <span class="st">&#39;__foo&#39;</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7"><span class="op">&gt;&gt;&gt;</span> a._A__foo()</a></code></pre></div><p>Name mangling is intended to give classes an easy way to define “private” instance variables and methods, without having to worry about instance variables defined by derived classes, or mucking with instance variables by code outside the class. Polymorphism is therefore associated with name mangling to access corresponding methods for different instances. This also reflects that all methods in Python are <a href="https://www.geeksforgeeks.org/virtual-function-cpp/" target="_blank" rel="noopener">virtual</a>.</p><blockquote><p><code>__double_leading_and_trailing_underscore__</code>: &quot;magic&quot; objects or attributes that live in user-controlled namespaces. E.g. <code>__init__</code>, <code>__import__</code> or <code>__file__</code>. Never invent such names; only use them as documented.</p></blockquote><h3 id="reference">Reference</h3><ol type="1"><li><a href="https://docs.python.org/3/tutorial/classes.html" target="_blank" rel="noopener">Classes Documentation</a></li><li><a href="https://www.geeksforgeeks.org/namespaces-and-scope-in-python/" target="_blank" rel="noopener">Namespaces and Scope in Python - GeeksforGeeks</a></li><li><a href="https://stackoverflow.com/questions/136097/difference-between-staticmethod-and-classmethod" target="_blank" rel="noopener">Difference between staticmethod and classmethod</a></li><li><a href="https://stackoverflow.com/questions/29614907/python-when-to-use-static-method-over-class-method" target="_blank" rel="noopener">When to use static method over class method?</a></li><li><a href="https://libcst.readthedocs.io/en/latest/metadata.html#scope-metadata" target="_blank" rel="noopener">Scope Metadata</a></li></ol></div></div><nav class="post-pagination"><span class="page-number"></span> <a class="older-posts" href="/2020/07/16/algebra/">Next post<br>Essence of Linear Algebra</a></nav></div></div><div class="single-column-footer">Proudly published with Hexo<br>Theme <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> by <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a><br>&copy; 2020 <a href="http://yoursite.com">Avalon</a></div></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.4/dist/umd/popper.min.js" integrity="sha256-EGs9T1xMHdvM1geM8jPpoo8EZ1V1VRsmcJz8OByENLA=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/bootstrap@4.1.3/dist/js/bootstrap.min.js" integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.5.17/dist/vue.min.js" integrity="sha256-FtWfRI+thWlNz2sB3SJbwKx5PgMyKIVgwHCTwa3biXc=" crossorigin="anonymous"></script><script src="https://cdn.jsdelivr.net/npm/smooth-scroll@14.2.1/dist/smooth-scroll.polyfills.min.js" integrity="sha256-CI4Gq5E0io1Pv0xM3qPM+NUIOhbIBvC3GiN1Y4KhXpw=" crossorigin="anonymous"></script><script src="/js/journal.js?71881722"></script></body></html>